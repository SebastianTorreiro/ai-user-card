"use server";

import { redirect } from "next/navigation";
import { google } from "@ai-sdk/google";
import { generateObject } from "ai";
import { z } from "zod";
import { supabase } from "@/lib/supabase";
import { ChampionSchema, ChampionFormSchema } from "@/lib/schemas"; // Importamos los nuevos schemas

export async function createCharacterAction(formData: FormData) {
  
  // 1. VALIDAR INPUT DEL USUARIO (Lo simple)
  const rawData = {
    name: formData.get("name"),
    class: formData.get("class"), // Ojo: en el form se llamará 'class', antes era 'role'
    region: formData.get("region"),
    prompt: formData.get("prompt"), // El campo extra opcional
  };

  const validation = ChampionFormSchema.safeParse(rawData);

  if (!validation.success) {
    console.error("Validation Error:", validation.error.format());
    throw new Error("Datos inválidos en el formulario.");
  }

  const { name, class: charClass, region, prompt: userPrompt } = validation.data;

  // 2. PROMPT ENGINEERING (El "Game Designer" Virtual)
  // Aquí le damos la personalidad de un desarrollador de Riot Games.
  const systemPrompt = `
    Eres un Lead Game Designer experto en MOBAs (como LoL o Dota).
    Tu tarea es diseñar un nuevo Campeón coherente, balanceado y con mecánicas únicas.

    Reglas de Diseño:
    1. Sinergia: Las habilidades deben interactuar entre sí (Ej: La Q marca, la E detona).
    2. Temática: Todo (Lore, Habilidades, Título) debe encajar con la Región "${region}" y la Clase "${charClass}".
    3. Balance: No hagas habilidades "rotas" (OP). Usa cooldowns y costos de maná realistas.
    4. Iconos: Los 'iconPrompt' deben ser descriptivos visualmente para generar iconos vectoriales.
    
    Detalles del Usuario: ${userPrompt ? `El usuario pide: "${userPrompt}"` : "Sé creativo."}
  `;

  // 3. GENERACIÓN DE ESTRUCTURA (JSON)
  let champion;
  try {
    const result = await generateObject({
      model: google("models/gemini-2.5-flash"),
      schema: ChampionSchema, // Usamos el schema gigante que creamos
      system: systemPrompt,   // Inyectamos la personalidad
      prompt: `Diseña a "${name}", un ${charClass} de ${region}.`,
    });
    champion = result.object;
  } catch (error) {
    console.error("AI Error:", error);
    throw new Error("La IA no pudo diseñar el campeón.");
  }

  // 4. GENERACIÓN DE IMAGEN (Splash Art)
  // Usamos la descripción visual que la IA generó para nosotros
  const imageUrl = `/api/image?prompt=${encodeURIComponent(champion.visualDescription + ", league of legends splash art style, high quality, 4k")}`;

  // 5. GUARDADO EN DB
  const { data, error } = await supabase
    .from("characters")
    .insert([
      {
        name: champion.name,
        title: champion.title,
        class: champion.class,
        region: champion.region,
        lore: champion.lore,
        stats: champion.stats,         // Se guarda como JSON automáticamente
        abilities: champion.abilities, // Se guarda como JSON automáticamente
        
        // Mapeo de campos legacy para que no rompa la UI vieja mientras migramos
        role: champion.class, 
        description: champion.visualDescription,
        image_url: imageUrl,
        company: champion.region, // Hack temporal
      },
    ])
    .select("id")
    .single();

  if (error) {
    console.error("DB Error:", error);
    throw new Error("Falló el guardado en base de datos.");
  }

  redirect(`/character/${data.id}`);
}







// create table public.characters (
//   id bigint generated by default as identity not null,
//   created_at timestamp with time zone not null default timezone ('utc'::text, now()),
//   name text not null,
//   role text not null,
//   description text not null,
//   image_url text null,
//   company text null,
//   city text null,
//   title text null,
//   region text null,
//   class text null,
//   abilities jsonb null,
//   constraint characters_pkey primary key (id)
// ) TABLESPACE pg_default;